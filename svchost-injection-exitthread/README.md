#Svchost Minimalist code injection

https://blogs.cisco.com/security/icedid-banking-trojan-teams-up-with-rovnix-for-distribution

Execution commandline -> 0d4aaa9860fa7fcba71eccd54a920369f4dc42e2ad53e835a7b9c3b69be30a7e /u

Once launched, Icedid takes advantage of an interesting technique to inject malicious code into svchost.exe. The code injection technique uses a very small number of Windows API functions. The technique also does not require starting the target process in a suspended state. The code injection is achieved by using only the following functions:
•	kernel32!CreateProcessA
•	ntdll!NtAllocateVirtualMemory
•	ntdll!ZwWriteVirtualMemory

Icedid’s code injection into svchost.exe works as follows:
1.	In the memory space of Icedid process the function ntdll!NtCreateUserProcess is hooked
2.	The function kernel32!CreateProcessA is called to launch svchost.exe, the CREATE_SUSPENDED flag is not set
3.	The hook on ntdll!NtCreateUserProcess is hit as a result of calling kernel32!CreateProcessA, the hook is then removed and the actual function call to ntdll!NtCreateUserProcess is made
a.	At this point the malicious process is still in the hook, the svchost.exe process has been loaded into memory by the operating system, but the main thread of svchost.exe has not yet started
4.	The call to ntdll!NtCreateUserProcess returns the process handle for svchost.exe. Using the process handle, the functions ntdll!NtAllocateVirtualMemory and ntdll!ZwWriteVirtualMemory can be used to write malicious code to the svchost.exe memory space
5.	In the svchost.exe memory space the call to ntdll!RtlExitUserProcess is hooked to jump to the malicious code already written to the svchost.exe memory space
6.	The malicious function returns, which continues the code initiated by the call to kernel32!CreateProcessA and the main thread of svchost.exe will be scheduled to run by the operating system
7.	The malicious process ends

Since svchost.exe has been called with no arguments, it would normally immediately shutdown because there is no service to launch. However, as part of its shutdown it will call ntdll!RtlExitUserProcess which hits the malicious hook and the malicious code will take over at this point.

